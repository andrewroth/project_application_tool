<%
require' yaml'

# load each yaml in /apps
apps = {}
for yaml in Dir['apps/*.yml']
  apps.merge(YAML::load(yaml)
end
#apps = {
#  'moose' => {:deploy_dir => 'moose.campusforchrist.org', :workers => 1, :env => 'production'},
#  'emu' => {:deploy_dir => 'emu.campusforchrist.org', :workers => 1, :env => 'production'}, 
#  'pulse' => {:deploy_dir => 'pulse.campusforchrist.org', :workers => 1, :env => 'production'} }
#
apps.each do |app, params|
  #rails_root = "/var/www/#{params[:deploy_dir]}/current"
  rails_root = "#{params[:deploy_to]}/current"
  params[:workers].times do |num|
    God.watch do |w|
      w.name = "dj-#{app}-#{num}"
      w.group = "dj-#{app}"
      w.interval = 30.seconds
      w.dir = rails_root
      w.env = { "RAILS_ENV" => params[:env] }
      w.log = "#{rails_root}/log/god.log"
      w.start = "rake jobs:work"
 
      w.uid = 'deploy'
      w.gid = 'www-data'
 
      # retart if memory gets too high
      w.transition(:up, :restart) do |on|
        on.condition(:memory_usage) do |c|
          c.above = 250.megabytes
          c.times = 2
        end
      end
 
      # determine the state on startup
      w.transition(:init, { true => :up, false => :start }) do |on|
        on.condition(:process_running) do |c|
          c.running = true
        end
      end
  
      # determine when process has finished starting
      w.transition([:start, :restart], :up) do |on|
        on.condition(:process_running) do |c|
          c.running = true
          c.interval = 5.seconds
        end
    
        # failsafe
        on.condition(:tries) do |c|
          c.times = 5
          c.transition = :start
          c.interval = 5.seconds
        end
      end
  
      # start if process is not running
      w.transition(:up, :start) do |on|
        on.condition(:process_running) do |c|
          c.running = false
        end
      end
    end
  end
end
